import io
import json
from datetime import datetime
from typing import Dict, Any, List
import pandas as pd

def generate_markdown_report(suggestions: Dict[str, Any], repo_info: Dict[str, str], analysis_options: Dict[str, bool]) -> str:
    """Generate a comprehensive markdown report of refactoring suggestions."""
    
    # Header
    report = f"""# Refactoring Analysis Report

**Repository:** {repo_info['full_name']}  
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Description:** {repo_info.get('description', 'No description')}  
**Main Language:** {repo_info.get('language', 'Unknown')}  
**Stars:** {repo_info.get('stars', 0)}  

---

## Executive Summary

This report contains refactoring recommendations generated by AI analysis to improve code quality, performance, and maintainability.

"""
    
    # Table of contents
    report += "## Table of Contents\n\n"
    toc_items = []
    
    if analysis_options.get('performance') and 'performance' in suggestions:
        toc_items.append("- [Performance Optimizations](#performance-optimizations)")
    if analysis_options.get('maintainability') and 'maintainability' in suggestions:
        toc_items.append("- [Maintainability Improvements](#maintainability-improvements)")
    if analysis_options.get('design_patterns') and 'design_patterns' in suggestions:
        toc_items.append("- [Design Pattern Recommendations](#design-pattern-recommendations)")
    if analysis_options.get('code_quality') and 'code_quality' in suggestions:
        toc_items.append("- [Code Quality Enhancements](#code-quality-enhancements)")
    if analysis_options.get('security') and 'security' in suggestions:
        toc_items.append("- [Security Recommendations](#security-recommendations)")
    if analysis_options.get('modularity') and 'modularity' in suggestions:
        toc_items.append("- [Modularity Improvements](#modularity-improvements)")
    
    toc_items.append("- [Summary and Recommendations](#summary-and-recommendations)")
    
    report += "\n".join(toc_items) + "\n\n"
    
    # Performance section
    if analysis_options.get('performance') and 'performance' in suggestions:
        report += generate_performance_section(suggestions['performance'])
    
    # Maintainability section
    if analysis_options.get('maintainability') and 'maintainability' in suggestions:
        report += generate_maintainability_section(suggestions['maintainability'])
    
    # Design patterns section
    if analysis_options.get('design_patterns') and 'design_patterns' in suggestions:
        report += generate_design_patterns_section(suggestions['design_patterns'])
    
    # Code quality section
    if analysis_options.get('code_quality') and 'code_quality' in suggestions:
        report += generate_code_quality_section(suggestions['code_quality'])
    
    # Security section
    if analysis_options.get('security') and 'security' in suggestions:
        report += generate_security_section(suggestions['security'])
    
    # Modularity section
    if analysis_options.get('modularity') and 'modularity' in suggestions:
        report += generate_modularity_section(suggestions['modularity'])
    
    # Summary section
    report += generate_summary_section(suggestions, analysis_options)
    
    return report

def generate_performance_section(performance_data: Dict[str, Any]) -> str:
    """Generate performance section of the report."""
    section = "## Performance Optimizations\n\n"
    
    if 'overall_score' in performance_data:
        section += f"**Overall Performance Score:** {performance_data['overall_score']}/10\n"
        section += f"**Issues Found:** {performance_data.get('issues_count', 0)}\n"
        section += f"**Optimizable Files:** {performance_data.get('optimizable_files', 0)}\n\n"
    
    if 'suggestions' in performance_data and performance_data['suggestions']:
        for i, suggestion in enumerate(performance_data['suggestions'], 1):
            section += f"### {i}. {suggestion.get('title', 'Performance Issue')}\n\n"
            section += f"**File:** `{suggestion.get('file', 'Unknown')}`  \n"
            section += f"**Priority:** {suggestion.get('priority', 'Medium')}  \n"
            section += f"**Impact:** {suggestion.get('impact', 'Unknown')}  \n\n"
            
            section += f"**Description:**\n{suggestion.get('description', 'No description')}\n\n"
            
            if 'before_code' in suggestion:
                section += "**Current Code:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['before_code']}\n```\n\n"
            
            if 'after_code' in suggestion:
                section += "**Optimized Code:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['after_code']}\n```\n\n"
            
            if 'explanation' in suggestion:
                section += f"**Why This Helps:**\n{suggestion['explanation']}\n\n"
            
            section += "---\n\n"
    else:
        section += "No performance issues identified.\n\n"
    
    return section

def generate_maintainability_section(maintainability_data: Dict[str, Any]) -> str:
    """Generate maintainability section of the report."""
    section = "## Maintainability Improvements\n\n"
    
    if 'metrics' in maintainability_data:
        metrics = maintainability_data['metrics']
        section += "**Maintainability Metrics:**\n"
        section += f"- Maintainability Index: {metrics.get('maintainability_index', 'N/A')}\n"
        section += f"- Complex Functions: {metrics.get('complex_functions', 0)}\n"
        section += f"- Long Files: {metrics.get('long_files', 0)}\n"
        section += f"- Code Duplication: {metrics.get('duplicate_percentage', 'N/A')}\n\n"
    
    if 'suggestions' in maintainability_data and maintainability_data['suggestions']:
        for i, suggestion in enumerate(maintainability_data['suggestions'], 1):
            section += f"### {i}. {suggestion.get('title', 'Maintainability Issue')}\n\n"
            section += f"**File:** `{suggestion.get('file', 'Unknown')}`  \n"
            section += f"**Category:** {suggestion.get('category', 'General')}  \n"
            section += f"**Effort Required:** {suggestion.get('effort', 'Medium')}  \n\n"
            
            section += f"**Recommendation:**\n{suggestion.get('description', 'No description')}\n\n"
            
            if 'current_approach' in suggestion:
                section += "**Current Approach:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['current_approach']}\n```\n\n"
            
            if 'improved_approach' in suggestion:
                section += "**Improved Approach:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['improved_approach']}\n```\n\n"
            
            if 'benefits' in suggestion and isinstance(suggestion['benefits'], list):
                section += "**Benefits:**\n"
                for benefit in suggestion['benefits']:
                    section += f"- {benefit}\n"
                section += "\n"
            
            section += "---\n\n"
    else:
        section += "No maintainability issues identified.\n\n"
    
    return section

def generate_design_patterns_section(design_patterns_data: Dict[str, Any]) -> str:
    """Generate design patterns section of the report."""
    section = "## Design Pattern Recommendations\n\n"
    
    if 'patterns_found' in design_patterns_data and design_patterns_data['patterns_found']:
        section += "**Existing Patterns Detected:**\n\n"
        section += "| Pattern | File | Quality |\n"
        section += "|---------|------|---------|\n"
        for pattern in design_patterns_data['patterns_found']:
            section += f"| {pattern.get('pattern', 'Unknown')} | `{pattern.get('file', 'Unknown')}` | {pattern.get('quality', 'Unknown')} |\n"
        section += "\n"
    
    if 'suggestions' in design_patterns_data and design_patterns_data['suggestions']:
        for i, suggestion in enumerate(design_patterns_data['suggestions'], 1):
            section += f"### {i}. {suggestion.get('pattern_name', 'Pattern Suggestion')}\n\n"
            section += f"**File/Module:** `{suggestion.get('file', 'Unknown')}`  \n"
            section += f"**Implementation Complexity:** {suggestion.get('complexity', 'Medium')}  \n\n"
            
            section += f"**Current Structure:**\n{suggestion.get('current_structure', 'No description')}\n\n"
            section += f"**Recommended Pattern:**\n{suggestion.get('recommended_pattern', 'No recommendation')}\n\n"
            
            if 'example_implementation' in suggestion:
                section += "**Example Implementation:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['example_implementation']}\n```\n\n"
            
            if 'benefits' in suggestion and isinstance(suggestion['benefits'], list):
                section += "**Benefits:**\n"
                for benefit in suggestion['benefits']:
                    section += f"- {benefit}\n"
                section += "\n"
            
            section += "---\n\n"
    else:
        section += "No design pattern improvements suggested.\n\n"
    
    return section

def generate_code_quality_section(code_quality_data: Dict[str, Any]) -> str:
    """Generate code quality section of the report."""
    section = "## Code Quality Enhancements\n\n"
    
    if 'quality_score' in code_quality_data:
        section += f"**Overall Quality Score:** {code_quality_data['quality_score']}/10\n"
        section += f"**Code Smells Found:** {code_quality_data.get('code_smells_count', 0)}\n"
        section += f"**Style Issues:** {code_quality_data.get('style_issues', 0)}\n\n"
    
    if 'suggestions' in code_quality_data and code_quality_data['suggestions']:
        for i, suggestion in enumerate(code_quality_data['suggestions'], 1):
            section += f"### {i}. {suggestion.get('title', 'Code Quality Issue')}\n\n"
            section += f"**File:** `{suggestion.get('file', 'Unknown')}`  \n"
            section += f"**Issue Type:** {suggestion.get('issue_type', 'General')}  \n"
            section += f"**Severity:** {suggestion.get('severity', 'Medium')}  \n\n"
            
            section += f"**Issue Description:**\n{suggestion.get('description', 'No description')}\n\n"
            
            if 'problematic_code' in suggestion:
                section += "**Problematic Code:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['problematic_code']}\n```\n\n"
            
            if 'improved_code' in suggestion:
                section += "**Improved Code:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['improved_code']}\n```\n\n"
            
            if 'explanation' in suggestion:
                section += f"**Why This Matters:**\n{suggestion['explanation']}\n\n"
            
            section += "---\n\n"
    else:
        section += "No code quality issues identified.\n\n"
    
    return section

def generate_security_section(security_data: Dict[str, Any]) -> str:
    """Generate security section of the report."""
    section = "## Security Recommendations\n\n"
    
    if 'security_score' in security_data:
        section += f"**Security Score:** {security_data['security_score']}/10\n"
        section += f"**Vulnerabilities Found:** {security_data.get('vulnerabilities_count', 0)}\n"
        section += f"**High Risk Issues:** {security_data.get('high_risk_issues', 0)}\n\n"
    
    if 'suggestions' in security_data and security_data['suggestions']:
        for i, suggestion in enumerate(security_data['suggestions'], 1):
            section += f"### {i}. {suggestion.get('title', 'Security Issue')}\n\n"
            section += f"**File:** `{suggestion.get('file', 'Unknown')}`  \n"
            section += f"**Risk Level:** {suggestion.get('risk_level', 'Medium')}  \n"
            section += f"**Vulnerability Type:** {suggestion.get('vulnerability_type', 'General')}  \n\n"
            
            section += f"**Security Issue:**\n{suggestion.get('description', 'No description')}\n\n"
            
            if 'vulnerable_code' in suggestion:
                section += "**Vulnerable Code:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['vulnerable_code']}\n```\n\n"
            
            if 'secure_code' in suggestion:
                section += "**Secure Code:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['secure_code']}\n```\n\n"
            
            if 'mitigation_steps' in suggestion and isinstance(suggestion['mitigation_steps'], list):
                section += "**Mitigation Steps:**\n"
                for step in suggestion['mitigation_steps']:
                    section += f"- {step}\n"
                section += "\n"
            
            section += "---\n\n"
    else:
        section += "No security issues identified.\n\n"
    
    return section

def generate_modularity_section(modularity_data: Dict[str, Any]) -> str:
    """Generate modularity section of the report."""
    section = "## Modularity Improvements\n\n"
    
    if 'cohesion_score' in modularity_data:
        section += f"**Cohesion Score:** {modularity_data['cohesion_score']}/10\n"
        section += f"**Coupling Issues:** {modularity_data.get('coupling_issues', 0)}\n"
        section += f"**Modules Analyzed:** {modularity_data.get('modules_count', 0)}\n\n"
    
    if 'suggestions' in modularity_data and modularity_data['suggestions']:
        for i, suggestion in enumerate(modularity_data['suggestions'], 1):
            section += f"### {i}. {suggestion.get('title', 'Modularity Issue')}\n\n"
            section += f"**Module/File:** `{suggestion.get('file', 'Unknown')}`  \n"
            section += f"**Issue Type:** {suggestion.get('issue_type', 'General')}  \n"
            section += f"**Impact:** {suggestion.get('impact', 'Medium')}  \n\n"
            
            section += f"**Current Structure:**\n{suggestion.get('current_structure', 'No description')}\n\n"
            section += f"**Recommended Refactoring:**\n{suggestion.get('recommended_refactoring', 'No recommendation')}\n\n"
            
            if 'example_refactoring' in suggestion:
                section += "**Example Refactoring:**\n"
                section += f"```{suggestion.get('language', 'text')}\n{suggestion['example_refactoring']}\n```\n\n"
            
            if 'benefits' in suggestion and isinstance(suggestion['benefits'], list):
                section += "**Benefits:**\n"
                for benefit in suggestion['benefits']:
                    section += f"- {benefit}\n"
                section += "\n"
            
            section += "---\n\n"
    else:
        section += "No modularity issues identified.\n\n"
    
    return section

def generate_summary_section(suggestions: Dict[str, Any], analysis_options: Dict[str, bool]) -> str:
    """Generate summary and recommendations section."""
    section = "## Summary and Recommendations\n\n"
    
    # Count total suggestions
    total_suggestions = 0
    high_priority = 0
    medium_priority = 0
    low_priority = 0
    
    for category_data in suggestions.values():
        if isinstance(category_data, dict) and 'suggestions' in category_data:
            total_suggestions += len(category_data['suggestions'])
            for suggestion in category_data['suggestions']:
                priority = suggestion.get('priority', suggestion.get('severity', suggestion.get('risk_level', 'Medium')))
                if priority == 'High' or priority == 'Critical':
                    high_priority += 1
                elif priority == 'Low':
                    low_priority += 1
                else:
                    medium_priority += 1
    
    section += f"**Total Suggestions:** {total_suggestions}\n"
    section += f"**High Priority:** {high_priority}\n"
    section += f"**Medium Priority:** {medium_priority}\n"
    section += f"**Low Priority:** {low_priority}\n\n"
    
    section += "### Recommended Implementation Order\n\n"
    section += "1. **Critical Security Issues** - Address any high-risk security vulnerabilities first\n"
    section += "2. **High-Impact Performance Issues** - Fix performance bottlenecks affecting user experience\n"
    section += "3. **Code Quality Improvements** - Improve maintainability and reduce technical debt\n"
    section += "4. **Design Pattern Implementation** - Enhance architecture for long-term maintainability\n"
    section += "5. **Modularity Enhancements** - Improve code organization and separation of concerns\n\n"
    
    section += "### Next Steps\n\n"
    section += "1. Review and prioritize the suggestions based on your project requirements\n"
    section += "2. Create issues or tasks in your project management system\n"
    section += "3. Implement changes incrementally, testing thoroughly\n"
    section += "4. Consider setting up automated tools to prevent regression\n"
    section += "5. Re-run this analysis periodically to track progress\n\n"
    
    section += f"---\n\n*Report generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n"
    
    return section

def generate_pdf_report(suggestions: Dict[str, Any], repo_info: Dict[str, str], analysis_options: Dict[str, bool]) -> io.BytesIO:
    """Generate a PDF report (simplified version)."""
    try:
        from reportlab.lib.pagesizes import letter
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Preformatted
        from reportlab.lib.styles import getSampleStyleSheet
        import html
        
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)
        styles = getSampleStyleSheet()
        story = []
        
        def escape_text(text):
            """Escape text for safe use in ReportLab Paragraph."""
            if not text:
                return ""
            # Escape HTML/XML characters
            escaped = html.escape(str(text))
            # Remove markdown formatting that could break PDF
            escaped = escaped.replace('**', '').replace('*', '').replace('`', '')
            # Remove problematic characters
            escaped = escaped.replace('<', '&lt;').replace('>', '&gt;')
            return escaped
        
        # Title
        repo_name = escape_text(repo_info.get('name', 'Unknown'))
        title = Paragraph(f"Refactoring Analysis Report - {repo_name}", styles['Title'])
        story.append(title)
        story.append(Spacer(1, 12))
        
        # Repository info
        description = escape_text(repo_info.get('description', 'No description'))
        language = escape_text(repo_info.get('language', 'Unknown'))
        stars = repo_info.get('stars', 0)
        
        info_text = f"""Repository: {escape_text(repo_info.get('full_name', ''))}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Description: {description}
Main Language: {language}
Stars: {stars}"""
        
        story.append(Paragraph(info_text, styles['Normal']))
        story.append(Spacer(1, 20))
        
        # Add sections based on available suggestions
        if 'performance' in suggestions and analysis_options.get('performance'):
            story.append(Paragraph("Performance Optimizations", styles['Heading2']))
            story.append(Spacer(1, 10))
            
            perf_data = suggestions['performance']
            if isinstance(perf_data, dict) and 'suggestions' in perf_data:
                for i, suggestion in enumerate(perf_data['suggestions'][:5]):  # Limit to 5 suggestions
                    if isinstance(suggestion, dict):
                        title = escape_text(suggestion.get('title', f'Suggestion {i+1}'))
                        file_path = escape_text(suggestion.get('file', 'Unknown file'))
                        description = escape_text(suggestion.get('description', 'No description'))
                        
                        story.append(Paragraph(f"{i+1}. {title}", styles['Heading3']))
                        story.append(Paragraph(f"File: {file_path}", styles['Normal']))
                        story.append(Paragraph(f"Description: {description}", styles['Normal']))
                        story.append(Spacer(1, 10))
            
            story.append(Spacer(1, 20))
        
        if 'maintainability' in suggestions and analysis_options.get('maintainability'):
            story.append(Paragraph("Maintainability Improvements", styles['Heading2']))
            story.append(Spacer(1, 10))
            
            maint_data = suggestions['maintainability']
            if isinstance(maint_data, dict) and 'suggestions' in maint_data:
                for i, suggestion in enumerate(maint_data['suggestions'][:5]):
                    if isinstance(suggestion, dict):
                        title = escape_text(suggestion.get('title', f'Suggestion {i+1}'))
                        file_path = escape_text(suggestion.get('file', 'Unknown file'))
                        description = escape_text(suggestion.get('description', 'No description'))
                        
                        story.append(Paragraph(f"{i+1}. {title}", styles['Heading3']))
                        story.append(Paragraph(f"File: {file_path}", styles['Normal']))
                        story.append(Paragraph(f"Description: {description}", styles['Normal']))
                        story.append(Spacer(1, 10))
            
            story.append(Spacer(1, 20))
        
        if 'code_quality' in suggestions and analysis_options.get('code_quality'):
            story.append(Paragraph("Code Quality Enhancements", styles['Heading2']))
            story.append(Spacer(1, 10))
            
            quality_data = suggestions['code_quality']
            if isinstance(quality_data, dict) and 'suggestions' in quality_data:
                for i, suggestion in enumerate(quality_data['suggestions'][:5]):
                    if isinstance(suggestion, dict):
                        title = escape_text(suggestion.get('title', f'Suggestion {i+1}'))
                        file_path = escape_text(suggestion.get('file', 'Unknown file'))
                        description = escape_text(suggestion.get('description', 'No description'))
                        
                        story.append(Paragraph(f"{i+1}. {title}", styles['Heading3']))
                        story.append(Paragraph(f"File: {file_path}", styles['Normal']))
                        story.append(Paragraph(f"Description: {description}", styles['Normal']))
                        story.append(Spacer(1, 10))
        
        # Summary
        story.append(Spacer(1, 20))
        story.append(Paragraph("Summary", styles['Heading2']))
        summary_text = "This report contains AI-generated refactoring suggestions to improve code quality, performance, and maintainability. Please review each suggestion carefully before implementation."
        story.append(Paragraph(summary_text, styles['Normal']))
        
        doc.build(story)
        buffer.seek(0)
        return buffer
        
    except Exception as e:
        # Enhanced fallback - create a simple text-based PDF alternative
        buffer = io.BytesIO()
        try:
            # Try to create a minimal PDF with just basic info
            from reportlab.platypus import SimpleDocTemplate, Paragraph
            from reportlab.lib.styles import getSampleStyleSheet
            
            doc = SimpleDocTemplate(buffer, pagesize=letter)
            styles = getSampleStyleSheet()
            story = []
            
            story.append(Paragraph("PDF Generation Error", styles['Title']))
            story.append(Paragraph(f"Error: {str(e)}", styles['Normal']))
            story.append(Paragraph("Please use the markdown export instead.", styles['Normal']))
            
            doc.build(story)
            buffer.seek(0)
            return buffer
            
        except:
            # Ultimate fallback - return error message as bytes
            error_msg = f"PDF generation failed: {str(e)}. Please use markdown export."
            buffer.write(error_msg.encode('utf-8'))
            buffer.seek(0)
            return buffer

def generate_excel_report(suggestions: Dict[str, Any], repo_info: Dict[str, str]) -> io.BytesIO:
    """Generate an Excel report with suggestions organized in sheets."""
    buffer = io.BytesIO()
    
    with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
        # Summary sheet
        summary_data = {
            'Repository': [repo_info['full_name']],
            'Description': [repo_info.get('description', 'No description')],
            'Language': [repo_info.get('language', 'Unknown')],
            'Stars': [repo_info.get('stars', 0)],
            'Generated': [datetime.now().strftime('%Y-%m-%d %H:%M:%S')]
        }
        summary_df = pd.DataFrame(summary_data)
        summary_df.to_excel(writer, sheet_name='Summary', index=False)
        
        # Create sheets for each category
        for category, data in suggestions.items():
            if isinstance(data, dict) and 'suggestions' in data and data['suggestions']:
                suggestions_list = []
                for suggestion in data['suggestions']:
                    row = {
                        'Title': suggestion.get('title', 'Untitled'),
                        'File': suggestion.get('file', 'Unknown'),
                        'Priority/Severity': suggestion.get('priority', suggestion.get('severity', suggestion.get('risk_level', 'Medium'))),
                        'Description': suggestion.get('description', 'No description'),
                        'Category': suggestion.get('category', suggestion.get('issue_type', suggestion.get('vulnerability_type', 'General'))),
                        'Impact': suggestion.get('impact', suggestion.get('effort', 'Medium'))
                    }
                    suggestions_list.append(row)
                
                df = pd.DataFrame(suggestions_list)
                sheet_name = category.replace('_', ' ').title()[:31]  # Excel sheet name limit
                df.to_excel(writer, sheet_name=sheet_name, index=False)
    
    buffer.seek(0)
    return buffer
